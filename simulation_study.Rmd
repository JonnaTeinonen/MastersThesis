---
title: "Simulation_draft_version2"
output: html_document
date: '2023-03-23'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
# All the libraries / packages used during the simulation
library(nnet) # For fitting multinomial logistic regression
library(mice) # For MICE
library(ResourceSelection) # For the Hosmer-Lemeshow test

```



# PART 1. Population Data Generation

```{r}
set.seed(13032023)

N <- 100000 # Size of full population

# Generates the auxiliary variables
x1 <- rbinom(N, 1, 0.5)
x2 <- rnorm(N, 4, 1)
x3 <- rnorm(N, 8, 2)
x4 <- rnorm(N, 3, 1) # Extra variable: used only in nonnested incorrect models

# Calculated the probabilities for unit to belong to each category of Y 
# (P(y = c)). Y = 1 is the reference category. 
p2 <- exp(-1.6*x1 + 0.3*x2 + 0.1*x3)/ (1 + exp(-1.6*x1 + 0.3*x2 + 0.1*x3) +
                                       exp(x1 - 1.3*x2 + 0.8*x3))

p3 <- exp(x1 - 1.3*x2 + 0.8*x3)/ (1 + exp(-1.6*x1 + 0.3*x2 + 0.1*x3) +
                                       exp(x1 - 1.3*x2 + 0.8*x3))

p1 <- 1 - p2 - p3

p_all <- cbind(p1, p2, p3) # Vector including all the true predictive scores


# Generates multinomial samples for C (= 3) categories using the the true 
# outcome probabilities. The code creates a matrix that has C rows 
# (one for each category of Y) and each row  has N observations. If value is 1, 
# observation belongs to that category, otherwise the value is 0. 
y <- apply(p_all, 1, function(x) rmultinom(1, 1, x))

# Create the final outcome variable: 
y_final <- list() # List for c vectors

# Loops through each category of Y
for(i in 1: nrow(y)){
  # If unit belongs to category c, the value is c, otherwise 0
  c <- ifelse(y[i, ] == 1, i, 0)
  y_final[[i]] <- c # Adds the vector c to the list
}

# Combines the vectors into a df so that each column represents the category of
# Y and rows the units. Next, it takes the sum of each row (each row has only 
# one number indicating the category of Y the unit belongs to) to gain one 
# vector which includes the category number for each unit
y <-as.factor(rowSums(do.call(cbind, y_final)))

# Creates a df with the dependent and auxiliary variables: our population
population <- cbind.data.frame(y, x1, x2, x3, x4)

# Save the true population data
save(population, file = "population_data.RData")
```



```{r}
# True population proportions
population_proportions <- table(population$y)/nrow(population)
population_proportions
```




# PART 2. Simulation


```{r}
# The outcome and response models are defined for each working model scenarios
# as they are needed for the simulation function

outcome_models_s1 <-list(as.formula("y ~ x1 + x2 + x3"), 
                       as.formula("y ~ x1 + x3"), 
                       as.formula("y ~ x1 + x2 + x4 + x3:x4"))

response_models_s1 <- list(as.formula("response ~ x1 + x2 + x3"), 
                           as.formula("response ~ x1 + x2"),
                           as.formula("response ~ x1 + x3 + x4 + x2:x4"))


outcome_models_s2 <-list(as.formula("y ~ x1 + x2 + x3"), 
                       as.formula("y ~ x1 + x3"), 
                       as.formula("y ~ x1 + x2 + x4 + x3:x4"))

response_models_s2 <- list(as.formula("response ~ x1 + x2"), 
                           as.formula("response ~ x1 + x3"),
                           as.formula("response ~ x1 + x3 + x4 + x2:x4"))


outcome_models_s3 <-list(as.formula("y ~ x1 + x3"), 
                       as.formula("y ~ x1 + x2"), 
                       as.formula("y ~ x1 + x2 + x4 + x3:x4"))

response_models_s3 <- list(as.formula("response ~ x1 + x2 + x3"), 
                           as.formula("response ~ x1 + x2"),
                           as.formula("response ~ x1 + x3 + x4 + x2:x4"))


outcome_models_s4 <-list(as.formula("y ~ x1 + x3"), 
                       as.formula("y ~ x1 + x2"), 
                       as.formula("y ~ x2 + x3"))

response_models_s4 <- list(as.formula("response ~ x1 + x2"), 
                           as.formula("response ~ x1 + x3"),
                           as.formula("response ~ x2 + x3"))


outcome_models_s5 <-list(as.formula("y ~ x1 + x2 + x4 + x3:x4"), 
                       as.formula("y ~ x1 + x2 + x4"), 
                       as.formula("y ~ x1 + x3 + x1:x4"))

response_models_s5 <- list(as.formula("response ~ x1 + x3 + x4 + x2:x4"), 
                           as.formula("response ~ x1 + x3 + x4"),
                           as.formula("response ~ x2 + x3 + x3:x4"))

```





## 2.1 Simulation With Robust Methods

```{r}
library(parallel)

# Simulation function to run the robust methods in parallel.
# Parameters:
# 1. iterations: M = number of wanted imputed datasets
# 2. population: The generated population with all the units
# 3. n: sample size
# 4. outcome_models: list of the outcome models formula
# 5. response_models: list of the response model formulas
# 6. RR: response rate which can be either "60", "70" or "80"

sim_study_robust <- function(iterations, 
                             population, 
                             n, 
                             outcome_models,
                             response_models,
                             RR){
  
  # Required R script to call the functions needed for the simulation
  source("simulation_fun.R")


  cores = detectCores() # Detects the number of available cores

  cl <- makeCluster(detectCores() - 1, type="PSOCK") # Creates the cluster
    
  # List of parameter functinos the function "fun_parallell_robust" requires 
  param_vector <- list(
      0, # placeholder for iter no
      population, 
      n, 
      outcome_models, 
      response_models,
      RR)
  
  
  macro_config <- list() # List for the parameter vectors
    
    
  # Creating parameter vector list for each iteration 
  for(s in 1:iterations){
    param_vector[[1]] <- s# Changes the placeholder based on iter number
    # List that includes the required parameter vectors lists for each iteration
    macro_config[[s]] <- param_vector

  }
    
  # Calls the required simulation functions using the given cluster and the 
  # different parameter vectors during each iteration
  all_MI_methods_parallel <- parLapply(cl, macro_config, fun_parallel_robust) 

   
  stopCluster(cl)

 }


```



```{r}

# Calling the simulation function
# NOTE: the parameters need to be changed to match the conditions we want to
# compute the imputed datasets
sim_study_robust(iterations = 5000, 
                        population = population, 
                        n = 50,
                        outcome_models = outcome_models_s1, 
                        response_models = response_models_s1,
                        RR = 60)


```




```{r}

# List for each robust method for the pooled parameter results
  MRNNI_pooled_param_list <- list()
  DRNNMI_pooled_param_list <- list()
  MRPMMI_pooled_param_list <- list()
  MICE_pooled_param_list <- list()
  MCIR_PseudoR2_MF_pooled_param_list <- list()
  MCIR_PseudoR2_CS_pooled_param_list <- list()
  MCIR_PseudoR2_MZ_pooled_param_list <- list()
  MCIR_PseudoR2_N_pooled_param_list <- list()
  MCIR_AIC_pooled_param_list <- list()
  MCIR_HL_pooled_param_list <- list()
  it_status_inf_list <- list() # List of the HL errors and other possible errors

sim_files <- list.files(path = "F:\\Thesis Project\\R code\\Main_draft\\Temporary_data\\parallel",
                                      pattern = ".rds", full.names = T)

iterno = 1

# Looping the 5000 files that include the results during each iteration
for(sim_file in sim_files){

  it_list <- readRDS(sim_file) # Results of all the robust methods for one iter

    MCIR_PseudoR2_MF_pooled_param_list[[iterno]] <- it_list[[1]]
    MCIR_PseudoR2_CS_pooled_param_list[[iterno]] <- it_list[[2]]
    MCIR_PseudoR2_MZ_pooled_param_list[[iterno]] <- it_list[[3]]
    MCIR_PseudoR2_N_pooled_param_list[[iterno]] <- it_list[[4]]
    MCIR_AIC_pooled_param_list[[iterno]] <- it_list[[5]]
    MCIR_HL_pooled_param_list[[iterno]] <- it_list[[6]]
    MRNNI_pooled_param_list[[iterno]] <- it_list[[7]]
    DRNNMI_pooled_param_list[[iterno]]  <- it_list[[8]]
    MRPMMI_pooled_param_list[[iterno]]  <- it_list[[9]]
    it_status_inf_list[[iterno]] <- it_list[[10]]
    iterno <- iterno + 1 # iteration number

}

# Combining the results of 5000 samples into one one list
# NOTE: name of the variable might need to be changed to match the right 
# conditions
simulation_rr60_n50_s1_robust <- list(
  MCIR_PseudoR2_MF_pooled_param_list,
                          MCIR_PseudoR2_CS_pooled_param_list,
                          MCIR_PseudoR2_MZ_pooled_param_list,
                          MCIR_PseudoR2_N_pooled_param_list,
                          MCIR_AIC_pooled_param_list,
                          MCIR_HL_pooled_param_list,
                          MRNNI_pooled_param_list,
                          DRNNMI_pooled_param_list,
                          MRPMMI_pooled_param_list
                   )

# Saving the results
save(simulation_rr60_n50_s1_robust , file = "simulation_rr60_n50_s1_robust.RData")
```


```{r}
# Combining the information related to errors that could have occurred during 
# the 5000 iterations
it_inf <- do.call(cbind, it_status_inf_list)

# Calculates the mean of each error
simulation_rr60_n50_s1_robust_it_inf <- apply(it_inf, 1, mean) 

# Saving the information
save(simulation_rr60_n50_s1_robust_it_inf, 
     file = "simulation_rr60_n50_s1_robust_it_inf.RData")
```




## 2.2 Simulation With MICE

```{r}
library(parallel)

# Simulation function to run the MICE variants in parallel.
# Parameters:
# 1. iterations: M = number of wanted imputed datasets
# 2. population: The generated population with all the units
# 3. n: sample size
# 4. outcome_models: list of the outcome models formula 
# 5. response_models: list of the response model formulas
# 6. RR: response rate which can be either "60", "70" or "80"

# NOTE: the outcome and response models that are given to the function are the
# same ones as that are given to the robust methods depending on the working 
# model scenario. This is done to check the HL error and so that MICE variants 
# use the same data in each working model scenario as did the robust methods.
# the models for the MICE variants are defined in the script "simulation_fun".

sim_study_mice <- function(iterations, 
                           population, 
                           n, 
                           outcome_models,
                           response_models,
                           RR){
  source("simulation_fun.R")

      
  

  cores = detectCores() # Number of available scores

  cl <- makeCluster(detectCores() - 1, type="PSOCK") # Creating a cluster
    
  # Parameter vector list
  param_vector <- list(
    0, # placeholder for iter no
    population, 
    n, 
    outcome_models,
    response_models,
    RR)
    
  # List for all the parameter vectors lists
  macro_config <- list()
  
  # Creating parameter vector list for each iteration   
  for(s in 1:iterations){
    param_vector[[1]] <- s # Changing placeholder to iter num
    macro_config[[s]] <- param_vector

  }

  # Calls the required simulation functions using the given cluster
  # and the different parameter vectors during each iteration
  all_MI_methods_parallel <- parLapply(cl, macro_config, fun_parallel_mice) 

  
   
  stopCluster(cl)

 }

```

```{r}
# Calling the simulation function
# NOTE: the parameters need to be changed to match the conditions we want to
# compute the imputed datasets

sim_study_mice(iterations = 5000, population = population, n = 50,
          outcome_models = outcome_models_s1,
          response_models = response_models_s1, 
          RR = 60)
```


```{r}
# List for each MICE variant for the pooled parameter results
MICE_default_pooled_param_list <- list()
MICE_CM_pooled_param_list <- list()
MICE_INM_pooled_param_list <- list()
MICE_INNM_pooled_param_list <- list()
it_status_inf_list <- list()

sim_files <- list.files(path = "F:\\Thesis Project\\R code\\Main_draft\\Temporary_data\\parallel",
                                      pattern = ".rds", full.names = T)

iterno = 1

# Looping the 5000 files that include the results during each iteration
for(sim_file in sim_files){

  it_list <- readRDS(sim_file)

    MICE_default_pooled_param_list[[iterno]] <- it_list[[1]]
    MICE_CM_pooled_param_list[[iterno]] <- it_list[[2]]
    MICE_INM_pooled_param_list[[iterno]] <- it_list[[3]]
    MICE_INNM_pooled_param_list[[iterno]] <- it_list[[4]]
    it_status_inf_list[[iterno]] <- it_list[[5]]
    iterno <- iterno + 1

}

# Combining the results of 5000 samples into one one list
# NOTE: name of the variable might need to be changed to match the right 
# conditions
simulation_rr60_n50_s1_MICE <- list(
  MICE_default_pooled_param_list,
  MICE_CM_pooled_param_list,
  MICE_INM_pooled_param_list,
  MICE_INNM_pooled_param_list)


# Saving the results
save(simulation_rr60_n50_s1_MICE, file = "simulation_rr60_n50_s1_MICE.RData")
```


```{r}
# Combining the information related to errors that could have occurred during 
# the 5000 iterations
it_inf <- do.call(cbind, it_status_inf_list)

# Calculates the mean of each error
simulation_rr60_n50_MICE_s1_it_inf <- apply(it_inf, 1, mean)

# Saving the information
save(simulation_rr60_n50_MICE_s1_it_inf, 
     file = "simulation_rr60_n50_s1_MICE_it_inf.RData")
```



## 2.3 Complete-Case Analysis (CCA)

```{r}
library(parallel)


sim_sample_prop <- function(iterations, 
                             population, 
                             n, 
                             outcome_models,
                             response_models,
                             RR){
  source("simulation_fun.R")

      
  

    cores = detectCores()

    cl <- makeCluster(detectCores() - 1, type="PSOCK")
    
    param_vector <- list(
      0, # placeholder for iter no
      population, 
      n, 
      outcome_models, 
      response_models,
      RR)
  
    macro_config <- list()
    
  for(s in 1:iterations){
    param_vector[[1]] <- s
    macro_config[[s]] <- param_vector

  }

    all_MI_methods_parallel <- parLapply(cl, macro_config, fun_sample_proportions) 

  
   
     stopCluster(cl)

 }


```


```{r}
sim_sample_prop(iterations = 5000, 
                        population = population, 
                        n = 50,
                        outcome_models = outcome_models_s1, 
                        response_models = response_models_s1,
                        RR = 60)

```

```{r}
# List for the CCA results
sample_proportions_RR60_n50_s1_list <- list()

combined_files <- list.files(path = "F:\\Thesis Project\\R code\\Main_draft\\Temporary_data\\sample proportions",
                                      pattern = ".rds", full.names = T)

iterno <- 1

# Looping through the 5000 files
for(file in combined_files){
  combined_file <- readRDS(file)
    sample_proportions_RR60_n50_s1_list[[iterno]] <- combined_file
    iterno <- iterno + 1

}
```


```{r}
# Combining the results from the list
sample_proportions_RR60_n50_s1 <- do.call(rbind, 
                                          sample_proportions_RR60_n50_s1_list)

# Calculating the mean proportions
sample_proportions_RR60_n50_s1_mean <- apply(sample_proportions_RR60_n50_s1, 
                                               2, mean)

# Calculating the SD of each the proportions
sample_proportions_RR60_n50_s1_sd <- apply(sample_proportions_RR60_n50_s1, 
                                             2, sd)

# Combining the results into a dataframe
sample_proportions_RR60_n50_s1 <- as.data.frame(
  cbind(sample_proportions_RR60_n50_s1_mean,
        sample_proportions_RR60_n50_s1_sd))

colnames(sample_proportions_RR60_n50_s1) <- c("ASP", "SD")
sample_proportions_R60_n50_s1 <- round(sample_proportions_RR60_n50_s1, 3)

# Saving the results
save(sample_proportions_RR60_n50_s1, 
     file = "sample_proportions_RR60_n50_s1.RData")
sample_proportions_RR60_n50_s1

```


